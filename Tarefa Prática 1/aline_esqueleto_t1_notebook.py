# -*- coding: utf-8 -*-
"""Aline_Esqueleto_T1_notebook.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sZbLz8RnOFNqKv8mAuSzY6hHz5JWxevb

Aline Freire de Rezende<br>116110571

# Python imports
"""

import numpy as np
import scipy as sp
from google.colab.patches import cv2_imshow
from google.colab import files
from matplotlib import patheffects
import matplotlib.pyplot as plt
import json

"""## JSON upload"""

from google.colab import files
uploaded = files.upload()

for fn in uploaded.keys():
  f = open(fn, )
  graphic_data = json.load(f)
  print('User uploaded file "{name}" with length {length} bytes'.format(name=fn, length=len(uploaded[fn])))

"""# Code (inside test and Screen class)"""

def inside(x, y, primitive):
  """
  Check if point (x,y) is inside the primitive
  
  Args:
    x (float): horizontal point position
    y (float): vertical point position
  Returns:
    True if (x,y) is inside the primitive, False case contrary
  """
  
  # You should implement your inside test here for all shapes   
  # for now, it only returns a false test

  return False

def buildsVector(pointA, pointB): # AB = B - A
  vector = np.zeros(2, int)

  iA = pointA[0]
  jA = pointA[1]
  iB = pointB[0]
  jB = pointB[1]

  vector[0] = iB-iA
  vector[1] = jB-jA

  return vector

def findNormal(vector): # é basicamente uma rotação horária
  normal = np.zeros(2, int)
  
  i = vector[0]
  j = vector[1]

  normal[0] = j
  normal[1] = -i

  return normal

def insideTriangle(x, y, triangle): # para rotação no sentido horário
  #inicialização de variáveis
  AB = BC = CA = np.zeros(2, int)
  Ap = Bp = Cp = np.zeros(2, int)
  nAB = nBC = nCA = np.zeros(2, int)
  alfaAB = alfaBC = alfaCA = 0
  
  # Ajustando os vertices e o ponto
  A = triangle[0]
  B = triangle[1]
  C = triangle[2]
  p = np.array([x,y])

  # Construindo os vetores do triângulo
  AB = buildsVector(A, B)
  BC = buildsVector(B, C)
  CA = buildsVector(C, A)
    
  # Construindo os vetores de cada vértice ao ponto
  Ap = buildsVector(A, p)
  Bp = buildsVector(B, p)
  Cp = buildsVector(C, p)

  # Encontrando as normais dos vetores do triângulo
  nAB = findNormal(AB)
  nBC = findNormal(BC)
  nCA = findNormal(CA)

  # Dot product das normais de cada vetor do triângulo com os vetores dos vértices aos pontos
  alfaAB = nAB @ Ap
  alfaBC = nBC @ Bp
  alfaCA = nCA @ Cp

  # Se todos os alfas forem positivos, sinal de que o ângulo é agudo e o ponto está dentro do triângulo
  if (alfaAB >= 0 and alfaBC >= 0 and alfaCA >= 0):
    return True

  return False

triangulo = np.array([[10,30], [60,100], [50,10]])
insideTriangle(40,60,triangulo)

class Screen:
  ''' Creates a virtual basic screen

    Args:
        gdata (dict): dictionary containing screen size and scene description
    '''

  def __init__(self, gdata):
    self._width = gdata.get("width")
    self._height = gdata.get("height")
    self._scene = self.preprocess( gdata.get("scene") )
    self.create_image()


  def preprocess(self, scene):
    ''' ?????????????

    Args:
      scene (dict): Scene containing the graphic primitives

    Returns:
      scene (dict): Scene containing the graphic primitives with additional info
    '''

    # Possible preprocessing with scene primitives, for now we don't change anything
    # You may define bounding boxes, convert shapes, etc
    preprop_scene = []

    for primitive in scene:
      # do some processing
      # for now, only copies each primitive to a new list
      
      preprop_scene.append(primitive)

    return preprop_scene

  def create_image(self):
    ''' Creates image with white background 
    
    Returns 
      image (numpy array): White image with R, G, B channels
    '''

    self._image = 255 *  np.ones((self._height, self._width, 3), np.uint8)

  def rasterize(self):
    ''' Rasterize the primitives along the Screen    
    '''
    
    for primitive in self._scene:
    # Loop through all pixels
    # You MUST use bounding boxes in order to speed up this loop
      for w in range(0, self._width):
        x = w + 0.5
        for h in range(0, self._height):
          y = h + 0.5
          # First, we check if the pixel center is inside the primitive
          if ( inside(x, y, primitive) ):
            im_x, im_y = w, self._height - (h + 1)
            self._image[im_y, im_x] = primitive['color'][::-1]
        

  def show(self, exec_rasterize = False):
    ''' Show the virtual Screen    
    '''

    if (exec_rasterize):
      self.rasterize()
      
    cv2_imshow(self._image)

"""# Virtual Screen

### Initialization
"""

screen = Screen(graphic_data)

"""### Rasterization and raster graphic visualization"""

screen.show(True)